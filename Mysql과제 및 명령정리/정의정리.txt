7장====================

SQL분류 : DDL, DML, DCL

데이터 정의어(DDL)
CREATE TABLE : 테이블 생성
ALTER TABLE : 테이블 변경
DROP TABLE : 테이블 삭제
CREATE VIEW : 뷰 생성
DROP BIEW : 뷰 삭제

데이터 조작어(DML)
SELECT : 데이터 검색
INSERT : 데이터 삽입
UPDATE : 데이터 수정
DELETE : 데이터 삭제

데이터 제어어 (DCL)

sql 의미
- 관계 데이터베이스를 위한 표준 질의어
- 비절차적 데이터 언어의 특징을 가짐

사용방식
- 대화식 sql : 데이터 베이스 관리 시스템에 직접 접근해 질의를 작성하여 실행
- 삽입 sql : 프로그래밍 언어로 작성된 응용 프로그램에 삽입

sql의 분류
1. DML = 데이터 조작어 : 테이블을 생성하고 변경,제거 하는 기능을 제공
2. DDL = 데이터 정의어 : 테이블에 새 데이터를 삽입, 테이블에 저장된 데이터를 수정,삭제,검색 하는기능을 제공
3. DCL = 데이터 제어어 : 보안을 위해 데이터에 대한 접근 및 사용 권한을 사용자별로 부여하거나 취소하는 기능을 제공

CREATE TABLE문을 구성하는 항목
1. 속성들의 이름
2. 데이터 타입 및 제약사항에 대한 정의
3. 기본키, 대체키, 외래키의 정의
4. 데이터 무결성을 위한 제약조건의 정의

예)
CREATE TABLE 테이블_이름(
1 - 속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본_값]
2 - [PRIMARY KEY (속성_리스트)]
3 - [UNIQUE (속성_리스트)]
4 - [FOREIGN KEY (속성_리스트) REFERENCES 테이블_이름(속성_리스트)] [ON DELETE 옵션] [ON UPDATE 옵션]
5 - [CONSTRAINT 이름] [CHECK(조건)]
);

1 : 테이블을 구성하는 각 속성의 이름, 데이터 타입, 기본제약 사항정의
2 : 기본키 정의
3 : 대체키 정의
4 : 외래키 정의
5 : 데이터 무결성을 위한 제약조건 정의
+[ ]의 내용은 생략가능, 질의문은 ;으로 문장의 끝을 표시, 질의문은 대소문자를 구분하지 않음

속성의 정의(CREATE TABLE문)
- 테이블을 구성하는 각 속성의 데이터 타입을 선택후 NULL값 허용여부와 기본값 필요여부 결정(create table문에서 생성된 테이블의 속성은 NULL값 허용)
- NOT NULL : 속성이 널 값을 허용하지 않는다는 의미
+ 기본키의 모든속성은 NULL값을 가질수없도록 해야됨 > 개체 무결성 제약조건 구현
- DEFAULT : 속성의 기본값을 지정하는 키워드

키의 정의(CREATE TABLE문)
- PRIMARY KEY : 기본키를 지정하는 키워드, 모든테이블에서 기본키는 반드시 하나만 지정가능, 여러개의 속성으로 구성할수있음
- UNIQUE : 대체키를 지정하는 키워드, 대체키의 속성의값은 유일성을 가지며 기본키와 달리 널값이 허용됨, 한테이블에서 여러게 지정가능
- FOREIGN KEY : 외래키를 지정하는 키워드, 외래키가 어떤 테이블의 무슨 속성을 참조하는지 REFERRENCES키워드 다음에 제시 
> 참조 무결성 제약조건 유지, 참조되는 테이블에서 튜플을 함부로 삭제하거나 변경하지 못함
> 참조 무결성 제약조건 유지를 위해 참조되는 테이블에서 튜블 변경시 처리바법을 지정하는 옵션
– ON UPDATE NO ACTION: 튜플을 변경하지 못하게 함
– ON UPDATE CASCADE: 관련 튜플에서 외래키 값을 함께 변경함
– ON UPDATE SET NULL: 관련 튜플의 외래키 값을 NULL로 변경함
– ON UPDATE SET DEFAULT: 관련 튜플의 외래키 값을 미리 지정한 기본 값으로 변경함

데이터 무결성 제약조건의 정의(CREATE TABLE문)
- CHECK : 키워드를 사용해 특정 속성에 대한 제약조건을 지정, CONSTRAINT 키워드와 함께 고유의 이름을 부여할수도 있음

뷰
- 다른테이블을 기반으로 만들어진 가상테이블
- 데이터를 실제로 저장하지 않고 논리적으로만 존재하는 테이블이지만, 일반 테이블과 동일한 방법으로 사용함
- 다른 뷰를 기반으로 새로운 뷰를 만드는 것도 가능
- 뷰를 통해 기본테이블의 내용을 쉽게 검색가능하지만, 기본테이블의 내용을 변화시키는 작업은 제한적으로 이루어짐

변경 불가능한 뷰
1. 기본 테이블의 기본키를 구성하는 속성이 포함되어있지 않은뷰
2. 기본 테이블에 있던 내용이 아닌 집계 함수로 새로 계산된 내용을 포함하는뷰
3. DISTICNT 키워드를 포함하여 정의한뷰
4. GROUP BY 절을 포함하여 정의한 뷰
5. 여러개의 테이블을 조인하여 정의한 뷰는 변경이 불가능한 경우가 많음

뷰의 장점
1. 질의문을 좀더 쉽게 작성할수있다.
2. 데이터의 보안 유지에 도움이 된다.
3. 데이터를 좀더 편리하게 관리할수있다.

삽입 sql : 프로그래밍 언어로 작성된 응용 프로그램 안에 삽입하여 사용하는 sql문 > C, C++, JAVA 등에서 사용
- 프로그램 안에서 일반 명령문이 위치할 수 있는곳이면 어디든 삽입가능
- 일반 명령문과 구별하기 위해 삽입 sql문 앞에 EXEC SQL을 붙임
- 프로그램에서 선언된 일반 변수를 삽입 sql문에서 사용할때는 이름앞에 콜론(:)을 붙여서 구분함
커서(CURSOR)
- 수행 결과로 반환된 여러 행을 한번에 하나씩 가리키는 포인터
- 여러 개의 행을 결과로 반환하는 SELECT문을 프로그램에서 사용할때 필요

커서가 필요없는 삽입 sql문
- CREATE TABLE문, INSERT문, DELETE문, UPDATE문 = 결과 테이블을 반환하지 않음
- 결과로 행 하나만 반환하는 SELECT문
삽입 sql문에서 사용할 변수 선언은 BEGIN DECLARE SECTION과 END DECLARE SECTION 사이에 선언
INTO 키워드를 이용하여 검색 결과를 저장할 변수 나열

커서가 필요한 삽입 SQL문
- SELECT문의 실행 결과로 여러행이검색되는 경우 필요

EXEC SQL DECLARE 커서_이름 CURSOR FOR SELECT 문;
> 커서를 사용하기전에 커서의 이름과 커서가 필요한 SELECT문을 선언

EXEC SQL OPEN 커서_이름;
> 커서에 연결된 SELECT문 실행

EXEC SQL FETCH 커서_이름 INTO 변수_리스트;
> 커서를 이동시키는 삽입 SQL문
> for, wile 문과 같은 반복문과 함께 사용
> 여러행이 사용해야되니까 FETCH문이 여러번 수행되야됨

EXEC SQL CLOSE 커서_이름;
> 커서의 사용을 종료하는 삽입 SQL문

8장====================

DB 설계

E-R 모델과 릴레이션 변환규칙을 이용한 설계 순서 > 각각의 결과물
1. 요구사항 분석 > 요구사항 명세서
2. 개념적 설계 > E-R 다이어그램
3. 논리적 설계 > 릴레이션 스키마
4. 물리적 설계 > 물리적 스키마
5. 구현

개념적 데이터 모델 : 사람의 머리로 이해할수 있도록 현실세계를 개념적 모델링해서 DB의 개념적 구조로 표현하는 도구
> 개체-관계 모델
논리적 데이터 모델 : 개념적 구조를 논리적 모델링하여 DB의 논리적 구조로 표현하는 도구
> 관계 데이터 모델

E-R 다이어 그램과 릴레이션 스키마의 차이점
- E-R 모델에서는 개체와 관계를 구분하지만, 관계 데이터 모델에서는 개체와 관계를 구분하지 않고 모두 릴레이션으로 표현
- E-R 모델에서는 다중 값 속성이나 복합속성을 허용 하지만 관계 데이터 모델에서는 허용하지 않음

9장====================

정규화 : 이상 현상을 제거하면서 DB를 올바르게 설계해 나가는 과정
이상현상 : DB를 잘못 설계하면 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터 (삽입,수정,삭제)연산을 수행할때 발생할수있는 부작용

이상현상 종류
삽입이상 : 새 데이터를 삽입하기위해 불필요한 데이터도 함께 삽입해야되는 문제 + 삽입이 안되는 문제
갱신이상 : 중복 투플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
삭제이상 : 투플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제

이상현상 발생 원인 : 관련 없는 속성들을 하나의 릴레이션에 모아두고 있기 때문
정규화 개념 : 함수 종속성을 이용해 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해서, 이상현상이 발생하지 않는 올바른 릴레이션으로 만들어가는 과정
정규화 방식 : 일반적으로 릴레이션에 함수적 종속성이 하나 존재하도록 정규화를 통해 릴레이션을 분해함
함수적 종속성(FD) : 속성들 간의 관련성

함수종속 : X가 Y를 함수적으로 결정한다 ( X(결정자) -> Y(종속자) )
- 릴레이션 내의 모든 튜플에서 하나의 X값에 대한 Y값이 항상 하나임

함수 종속 관계판단시 유의사항
- 속성 자체의 특성과 의미를 기반으로 함수 종속성을 판단해야됨
- 일반적으로 기본키와 후보키는 릴레이션의 다른 모든 속성들을 함수적으로 결정함

함수 종속 관계 예) X -> Z, {X, Y} -> N, {X, Y} -> Z 인경우
부분함수 종속 : Z는 {X, Y}에 종속되어 있으면서 {X, Y}의 일부분인 X에 종속되어있음 -> Z는 {X, Y}에 부분 함수 종속됨
완전함수 종속 : N은 {X, Y}의 일부분이 아닌 속성 집합 전체에 종속되어 있어서, 완전함수 종속되었다고함

+ 결정자와 종속자가 같거나 (X -> X), 결정자가 종속자를 포함하는것처럼 당연한 함수 종속관계는 고려하지 않음

정규형 : 정규형의 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격해짐, 릴레이션의 특성을 고려해서 적합한 정규형을 선택

기본 정규형 종류
제 1 정규형 : 릴레이션에 속한 모든 속성의 도메인이 원자값 으로만 구성되어있는거 > 이상현상 발생
제 2 정규형 : 릴레이션이 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속된거 > 이상현상 발생
제 3 정규형 : 릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면됨 > 후보키가 여러개이면 이상현상 발생
보이스/코드 정규형 (BCNF) : 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 이에 속함

정규화시 주의사항
- 모든 릴레이션이 제 5 정규형에 속해야만 바람직한것은 아님
- 일밙거으로 제 3정규형 이나 BCNF에 속하도록 릴레이션을 분해하여 데이터 중복을 줄이고 이상현상을 해결하는 경우가 많음

10장====================

트랜잭션 : 하나의 작업을 수행하는데 필요한 DB연산들을 모아놓은 것으로, DB에서 논리적인 작업의 단위를 의미함
- 장애가 생겼을때 복구작업, 다수의 사용자가 동시에 사용할수있도록 병행 제어 작업을위한 작업단위로 사용
- INSERT, DELETE, UPDATE 문의 실행을 관리

트랜잭션의 ACID특성 - 무결성과 일관성이 보장되려면 4가지 특성을 만족해야됨
1. 원자성 : 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야하는 all-or-nothing 방식을 의미
2. 일관성 : 트랜잭션이 성공적으로 수행된 후에도 DB가 일관된 상태를 유지해야 함을 의미
3. 격리성 : 수행중인 드랜잭션이 완료될때까지 다른 트랜잭션들이 중간 연산 결과에 접근할수 없음을 의미
4. 지속성 : 트랜잭션이 성공적으로 완료된 후 DB에 반영한 수행결과는 어떠한 경우에도 손실되지 않고 영구적이어야 함을 의미

트랜잭션의 특성을 지원하는 DBMS의 기능
원자성, 지속성 > 보장을 위해서는 장애발생시 회복기능이 필요
일관성, 격리성 > 보장을 위해서는 병행제어 기능 필요

드랜잭션의 연산
commit 연산 : 트랜잭션이 성공적으로 수행되었음을 선연(작업완료)
rollback 연산 : 트랜잭션을 수행하는데 실패했음을 선언(작업취소)

트랜잭션의 상태 : 트랜잭션은 (활동, 부분완료, 실패, 완료, 철회) 5가지 상태중 하나에 속함
활동 -> 부분완료 | 실패 -> 실패 or 완료 | 철회

활동 상태 : 트랜잭션이 수행되기 시작하여 현재 수행중인 상태
부분완료 상태 : 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태, 최종결과를 DB에 아직 반영하지 않은상태
완료 상태 : 트랜잭션이 성공적으로 완료되어 commit연산을 실행한 상태, 최종결과를 DB에 반영하고 DB가 새로운 일관된 상태가되면서 트랜잭션이 종료됨
실패 상태 : 장애가 발생하여 트랜잭션의 수행이 중단된 상태
철회 상태 : 트랜잭션의 수행 실패로 rollback 연산을 실행한 상대, 모든 연산을 취소하고 수행되기전의 DB상태로 되돌리면서 트랜잭션이 종료됨, 이후 트랜잭션은 상황에따라 다시 수행되거나 폐기됨